<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>Stereo Image Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: black;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>

<body>
    <div id="ui">
        瞳距调整：
        <input id="ipd" type="range" min="0.0" max="0.2" step="0.001" value="0.06">
    </div>

    <script type="module">
        import * as THREE from './src/Three.js';
        import { VRButton } from './src/webxr/VRButton.js';

        let scene, camera, renderer;
        let leftMesh, rightMesh;
        let ipd = 0.06; // 初始瞳距（单位：米）

        init();
        animate();

        function init ()
        {
            // 场景和相机
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );

            // 渲染器
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.xr.enabled = true;
            document.body.appendChild( VRButton.createButton( renderer ) );
            document.body.appendChild( renderer.domElement );

            // 纹理加载器
            const loader = new THREE.TextureLoader();

            let leftTex, rightTex;
            let aspect = 1; // default aspect ratio

            leftTex = loader.load("./left.jpg", function (texture) {
                if (texture.image) {
                    aspect = texture.image.width / texture.image.height;
                    leftTex.minFilter = THREE.LinearFilter;

                    rightTex = loader.load("./right.jpg", function (rightTexture) {
                        rightTex.minFilter = THREE.LinearFilter;

                        // 左右眼平面
                        const leftGeometry = new THREE.PlaneGeometry(aspect, 1);
                        const rightGeometry = new THREE.PlaneGeometry(aspect, 1);
                        const leftMat = new THREE.MeshBasicMaterial({ map: leftTex });
                        const rightMat = new THREE.MeshBasicMaterial({ map: rightTex });

                        // 创建左右眼 mesh
                        leftMesh = new THREE.Mesh(leftGeometry, leftMat);
                        rightMesh = new THREE.Mesh(rightGeometry, rightMat);

                        // 放在相机前方
                        leftMesh.position.z = -0.8;
                        leftMesh.position.y = 1.2;
                        rightMesh.position.z = -0.8;
                        rightMesh.position.y = 1.2;

                        // 设置 Layer：0 = 左眼，1 = 右眼
                        leftMesh.layers.set(1);   // 专给左眼
                        rightMesh.layers.set(2);  // 专给右眼

                        scene.add(leftMesh);
                        scene.add(rightMesh);
                    });
                }
            });

            // 监听滑块变化
            document.getElementById( "ipd" ).addEventListener( "input", ( e ) =>
            {
                ipd = parseFloat( e.target.value );
            } );

            window.addEventListener( "resize", onWindowResize );

            // 滾輪、手柄上下控制距離
            renderer.domElement.addEventListener( 'wheel', ( e ) =>
            {
                e.preventDefault();
                const delta = e.deltaY * 0.01;
                leftMesh.position.z += delta;
                rightMesh.position.z += delta;
            } );
        }

        function onWindowResize ()
        {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function animate ()
        {
            renderer.setAnimationLoop( render );
        }

        function render ( time, frame )
        {
            if ( frame )
            {
                const session = renderer.xr.getSession();
                const pose = frame.getViewerPose( renderer.xr.getReferenceSpace() );

                if ( pose )
                {
                    for ( const view of pose.views )
                    {
                        if ( view.eye === "left" )
                        {
                            camera.layers.enable( 1 ); // 左眼只看 Layer 1
                            camera.layers.disable( 2 );
                            leftMesh.position.x = -ipd / 2;
                        } else if ( view.eye === "right" )
                        {
                            camera.layers.enable( 2 ); // 右眼只看 Layer 2
                            camera.layers.disable( 1 );
                            rightMesh.position.x = ipd / 2;
                        }
                    }
                }
            }

            renderer.render( scene, camera );
        }
    </script>
</body>

</html>