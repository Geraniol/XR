<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Stereo Image Viewer (Quest3)</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #ui {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      color: white;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="ui">
    瞳距调整：
    <input id="ipd" type="range" min="0.0" max="0.2" step="0.001" value="0.06">
  </div>

  <script type="module">
    import * as THREE from './src/Three.js';
    import { VRButton } from './src/webxr/VRButton.js';
    import { XRControllerModelFactory } from './src/webxr/XRControllerModelFactory.js';

    let scene, camera, renderer;
    let leftMesh, rightMesh;
    let ipd = 0.06;

    let controller1, controllerGrip1;
    let raycaster, tempMatrix = new THREE.Matrix4();
    let intersected = null;
    let isDragging = false;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      const loader = new THREE.TextureLoader();
      const leftTex = loader.load("./left.jpg");
      const rightTex = loader.load("./right.jpg");

      const geom = new THREE.PlaneGeometry(1.6, 0.9);
      const leftMat = new THREE.MeshBasicMaterial({ map: leftTex, side: THREE.DoubleSide });
      const rightMat = new THREE.MeshBasicMaterial({ map: rightTex, side: THREE.DoubleSide });

      leftMesh = new THREE.Mesh(geom, leftMat);
      rightMesh = new THREE.Mesh(geom, rightMat);
      leftMesh.position.z = -2;
      rightMesh.position.z = -2;

      // 设置 layer：左图给 Layer1，右图给 Layer2
      leftMesh.layers.set(1);
      rightMesh.layers.set(2);

      scene.add(leftMesh);
      scene.add(rightMesh);

      // --- 手柄控制 ---
      raycaster = new THREE.Raycaster();

      controller1 = renderer.xr.getController(0);
      scene.add(controller1);

      controllerGrip1 = renderer.xr.getControllerGrip(0);
      const controllerModelFactory = new XRControllerModelFactory();
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);

      document.getElementById("ipd").addEventListener("input", (e) => {
        ipd = parseFloat(e.target.value);
      });

      window.addEventListener('resize', onWindowResize);
    }

    function onSelectStart() {
      // 手柄射线检测
      tempMatrix.identity().extractRotation(controller1.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

      const intersects = raycaster.intersectObjects([leftMesh, rightMesh]);
      if (intersects.length > 0) {
        intersected = intersects[0].object;
        isDragging = true;
      }
    }

    function onSelectEnd() {
      isDragging = false;
      intersected = null;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(time, frame) {
      if (frame) {
        const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());
        if (pose) {
          for (const view of pose.views) {
            if (view.eye === "left") {
              camera.layers.enable(1);
              camera.layers.disable(2);
              leftMesh.position.x = -ipd / 2;
            } else if (view.eye === "right") {
              camera.layers.enable(2);
              camera.layers.disable(1);
              rightMesh.position.x = ipd / 2;
            }
          }
        }
      }

      // 拖拽逻辑：让图片跟随手柄
      if (isDragging && intersected) {
        intersected.position.setFromMatrixPosition(controller1.matrixWorld);
        intersected.position.z -= 2; // 保持在视野前方一点
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
