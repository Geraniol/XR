<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Stereo Image Viewer (Quest3)</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #ui {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      color: white;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="ui">
    瞳距调整：
    <input id="ipd" type="range" min="0.0" max="0.2" step="0.001" value="0.06">
  </div>

  <script type="module">
    import * as THREE from './src/Three.js';
    import { VRButton } from './src/webxr/VRButton.js';
    import { XRControllerModelFactory } from './src/webxr/XRControllerModelFactory.js';

    let scene, camera, renderer;
    let leftMesh, rightMesh;
    let ipd = 0.06;

    // 控制器
    let controller1, controllerGrip1, controller2, controllerGrip2;
    let raycaster, tempMatrix = new THREE.Matrix4();

    // 抓取状态
    let grabbed = new Set();   // 哪些控制器正在抓取
    let grabbedObject = null;  // 被抓取的对象（图片）
    let initialDistance = 0;
    let initialScale = 1;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(VRButton.createButton(renderer));
      document.body.appendChild(renderer.domElement);

      const loader = new THREE.TextureLoader();
      const leftTex = loader.load("./left.jpg");
      const rightTex = loader.load("./right.jpg");

      const geom = new THREE.PlaneGeometry(1.6, 0.9);
      const leftMat = new THREE.MeshBasicMaterial({ map: leftTex, side: THREE.DoubleSide });
      const rightMat = new THREE.MeshBasicMaterial({ map: rightTex, side: THREE.DoubleSide });

      leftMesh = new THREE.Mesh(geom, leftMat);
      rightMesh = new THREE.Mesh(geom, rightMat);
      leftMesh.position.z = -2;
      rightMesh.position.z = -2;

      // 设置 layer
      leftMesh.layers.set(1);
      rightMesh.layers.set(2);

      scene.add(leftMesh);
      scene.add(rightMesh);

      // --- 控制器 ---
      raycaster = new THREE.Raycaster();
      const controllerModelFactory = new XRControllerModelFactory();

      controller1 = renderer.xr.getController(0);
      controller2 = renderer.xr.getController(1);
      scene.add(controller1);
      scene.add(controller2);

      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      controller1.addEventListener('selectstart', (e) => onSelectStart(e, controller1));
      controller1.addEventListener('selectend',   (e) => onSelectEnd(e, controller1));
      controller2.addEventListener('selectstart', (e) => onSelectStart(e, controller2));
      controller2.addEventListener('selectend',   (e) => onSelectEnd(e, controller2));

      document.getElementById("ipd").addEventListener("input", (e) => {
        ipd = parseFloat(e.target.value);
      });

      window.addEventListener('resize', onWindowResize);
    }

    function intersectObject(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

      return raycaster.intersectObjects([leftMesh, rightMesh]);
    }

    function onSelectStart(event, controller) {
      const intersects = intersectObject(controller);
      if (intersects.length > 0) {
        grabbed.add(controller);
        grabbedObject = intersects[0].object;

        if (grabbed.size === 2) {
          // 双手开始抓取，记录初始状态
          const p1 = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
          const p2 = new THREE.Vector3().setFromMatrixPosition(controller2.matrixWorld);
          initialDistance = p1.distanceTo(p2);
          initialScale = grabbedObject.scale.x;
        }
      }
    }

    function onSelectEnd(event, controller) {
      grabbed.delete(controller);
      if (grabbed.size === 0) {
        grabbedObject = null;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(time, frame) {
      if (frame) {
        const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());
        if (pose) {
          for (const view of pose.views) {
            if (view.eye === "left") {
              camera.layers.enable(1);
              camera.layers.disable(2);
              leftMesh.position.x = -ipd / 2;
            } else if (view.eye === "right") {
              camera.layers.enable(2);
              camera.layers.disable(1);
              rightMesh.position.x = ipd / 2;
            }
          }
        }
      }

      // --- 抓取逻辑 ---
      if (grabbedObject) {
        if (grabbed.size === 1) {
          // 单手拖动
          const controller = Array.from(grabbed)[0];
          grabbedObject.position.setFromMatrixPosition(controller.matrixWorld);
          grabbedObject.position.z -= 2; // 保持前方一点
        } else if (grabbed.size === 2) {
          // 双手缩放
          const p1 = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
          const p2 = new THREE.Vector3().setFromMatrixPosition(controller2.matrixWorld);
          const currentDistance = p1.distanceTo(p2);
          const scale = initialScale * (currentDistance / initialDistance);
          grabbedObject.scale.set(scale, scale, scale);

          // 旋转（双手连线朝向）
          const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          grabbedObject.position.copy(mid);
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
